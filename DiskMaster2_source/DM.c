/* DiskMaster2  main module  startup/exit
**
** 2.5.29
**
** 04-02-01 rri - Set version to 2.5.29
**
** 04-04-02 rri - Adjusted the release-date a bit.
**              - Replaced 12 "#ifdef __PPC__" with "#ifdef __amigaos4__".
**              - Using the V50.1 includes it's "struct UtilityBase" now - oh dear...
**
** 04-04-04 rri - Set release date
**
** 2.5.30
**
** 04-04-06 rri - Set version to 2.5.30
**
** 2.5.31
**
** 04-10-12 rri - GfxBase, IntuitionBase, LocaleBase, RexxSysBase and
**                UtilityBase are of type struct Library for OS4.
**              - use30-flag is set by default for the OS4 compiled version.
**              - Set version to 2.5.31
**
** 04-10-31 rri - Changed prototype for LibOpen() to avoid some nasty and useless warnings
**                with GCC 3.4.2 for OS4.
**              - Changed all LibOpen() calls to the new format.
**
** 04-12-22 rri - Removed LibDeletePool() and LibCreatePool() -> DM2 goes V39+!
**              - Bumped the minimum version-number for most libs to 39 -> DM2 goes V39+!
**
** 05-03-21 rri - Finally got rid of the default-output window from the GCC startup-code.
**
** 05-03-26 rri - Bugfix: without 'Font' command some fonts could be left un-initialised.
**              - Changed default font from TOPAZ to what font is used on the default pupscreen.
**
** 05-03-27 rri - Set release date.
**
** 2.5.32
**
** 05-06-11 rri - Set version to 2.5.32 and the release date.
**
** 2.6
**
** 05-06-14 jjt - InitLibsPortsPools() - Added Reaction libs.
**              - LibOpen() - Added a check to possibly bypass appending ".library" to <name>.
**                Reaction libs have their own extensions.
**
** 05-06-18 rri - Set version to 2.5.33
**              - Increased LibBasePtrs[] and IFacePtrs[] to thirty.
**              - Added OS4 specific lines for reaction-classes to InitLibsPortsPools().
**
** 05-06-24 jjt - DM2main() - Moved the line assigning ReadHist's mempool after the
**                StrHist_Init() call (so it actually has some effect).
**              - Created CmdHist, and added a line to DM2main() to initialize it.
**
** 05-07-17 rri - Changed the format of the $VER string to fully comply with
**                the specifications for AmigaOS.
**              - Changed all references to "2.5.33" into "2.6".
**              - Removed comments from header older than 2.5.29.
**
** 05-07-31 rri - Just changed the comment style for the "jjt KLUDGE" to ANSI. :-)
**
** 05-08-27 rri - Added initialisation of Layers.library
**
** 05-08-30 rri - Added more Reaction components for the new DMPreferences.c
**
** 05-09-01 jjt - Added more Reaction components for DMPreferences.c.
**
** 05-09-16 jjt - Added palette and slider ReAction components for DMPreferences.c
**
** 05-11-05 rri - Adjusted the release-date a little...
**
** 05-11-08 jjt - Added code to initialize ViewA_Semaphore and DiskMaster2Guide.
**
** 05-11-19 rri - Changed back the minimal required version for all 68k reaction classes
**                to V41 to meet the Classact2Demo from Aminet.
**
** 05-11-20 rri - Set release-date and changed version to 2.6RC1 to allow generating
**                a test-version that has a correct date.
**
** 05-11-23 jjt - DM2main() - Initializes the button text for reqtags_Ok and
**                reqtags_HelpOkSkipCan.
**
** 05-11-26 rri - Set release-date and changed version to 2.6RC2.
**              - Changing to DiskMaster2.catalog also renamed the locale
**                functions that are generated by FlexCat.
**
** 05-11-27 rri - Adjusted the minimum required versions of most libs and
**                classes to V50 for the OS4 version which meets the
**                OS4 pre-release.
**              - Set release-date and changed version to 2.6RC3.
**
** 05-12-03 rri - Set release-date and changed version to 2.6RC4.
**
** 05-12-10 rri - Set release-date and changed version to 2.6RC5.
**
** 2.7
**
** 05-12-15 jjt - Added listbrowser ReAction components for DMPreferences.c.
**              - Changed the version to 2.7.
**
** 06-01-05 rri - Added init for Scroller.gadget and Space.gadget
**              - Changed release-date.
**
** 06-03-05 rri - Conditionally removed IUtility for compiling for Newlib.library.
**              - Various changes to the different strings removed all signed<>unsigned
**                warnings without "-Wno-pointer-sign" when using GCC.
**
** 06-03-11 rri - Changed the define for Newlib to "__NEWLIB__".
**
** 06-08-26 rri - Removed some test-code
**              - Changed release date to 2006-1x-xx
**
** 06-09-17 rri - Removed not used Space.gadget
**
** 06-1x-xx rri - Added bevel.image for cmd-window ListBrowser buttons
**
** 06-12-03 rri - Moved removal of WinPort from FreeUserData to DM2main(),
**                this way it does not go away during 'Iconify' or reset.
**
** 06-12-04 rri - Added default initialisation of struct DirInfo DInfo to DM2main().
**
** 06-12-05 rri - Set Version[]="DiskMaster 2.7b1" and
**                VerstrA[]="\0$VER: DiskMaster 2.7 (05.12.2006) R.Riedel" - first beta-release
**                to OS4 beta-testers.
**              - All fonts are initialised to the screen font now (Screen_TAttr).
**              - Removed some test-code from DM2main().
**
** b2
**
** 06-12-10 rri - Set Version[]="DiskMaster 2.7b2" and
**                VerstrA[]="\0$VER: DiskMaster 2.7 (10.12.2006) R.Riedel" - second
**                beta-release to OS4 beta-testers.
**              - Added init of sort-types to the default initialisation of DInfo in DM2main().
**
** b3
**
** 06-12-12 rri - Set Version[]="DiskMaster 2.7b3"
**
** 06-12-14 rri - Set date to 2006-12-14 for the third beta-release.
*+
** b4
**
** 06-12-16 rri - Set Version[]="DiskMaster 2.7b4" and
**                VerstrA[]="\0$VER: DiskMaster 2.7 (17.12.2006) R.Riedel" - fourth
**                beta-release to OS4 beta-testers.
**
** 06-12-17 rri - Set the minimal required version to V52 for the OS4 build.
**              - Removed not used Layers.library and Scroller.gadget from the OS4 build.
**
** b5
**
** 06-12-19 rri - Set Version[]="DiskMaster 2.7b5" and
**                VerstrA[]="\0$VER: DiskMaster 2.7 (19.12.2006) R.Riedel" - fifth
**                beta-release to OS4 beta-testers.
**
** b6
**
** 06-12-21 rri - Set Version[]="DiskMaster 2.7b6" and
**                VerstrA[]="\0$VER: DiskMaster 2.7 (21.12.2006) R.Riedel" - sixth
**                beta-release to OS4 beta-testers.
**
** b7
**
** 06-12-26 rri - DMFONTS_READER is initialised to Topaz in case the screen-font is proportional.
**              - Set Version[]="DiskMaster 2.7b7"
**
** 06-12-28 rri - Added init of DMTextAttrs[].
**              - Replaced Screen_TAttr with DMTextAttrs[DMFONTS_SCREEN].
**
** 06-12-30 rri - Modified some old-style "timerequest" vars to "TimeRequest" as this was changed to that
**                name in the OS4-SDK for use with Timer.device.
**              - Modified some old-style "timeval" vars to "TimeVal" as this was changed to that
**                name in the OS4-SDK for use with Timer.device.
**              - Modified proto for StartTimer() to use an uint32 because TimeVal.Seconds *is* uint32,
**                not int32...
**              - Set date to 2006-12-30 for new release on OS4Depot.
**              - Replaced a reference to dir_gad in MainLoop() by dwgad[GID_String].
**
** 07-01-02 rri - Set release-date to 2007-01-02 as a last-minute bug in 'Swap' delayed the release.
**              - Removed the obsolete var "LastI".
**              - Conditionally removed the check for long months for the OS4 build.
**
** b8
**
** 07-01-03 rri - Set Version[]="DiskMaster 2.7b8"
**              - Set date to 2006-01-06 for next release on OS4Depot.
**              - Implemented AmiUpdate ENV: support.
**
** 07-01-05 rri - The path-string for the AmiUpdate support is now build using DevNameFromLock()
**                for the OS4 build to avoid problems with not unique volume-names.
**              - Set date to 2007-01-05 to send Javier a test-version for localisation.
**
** 07-01-08 rri - Activated Layers.lib again.
**              - Set date to 2007-01-08 for new release on OS4Depot.
**
** b9
**
** 07-01-10 rri - Set Version[]="DiskMaster 2.7b9"
**              - Set date to 2007-01-10 to send Javier annother test-version.
**
** 07-01-17 rri - Set date to 2007-01-20 for next scheduled release.
**              - Localised the default DInfo.titles.
**
** 07-01-21 rri - Set date to 2007-01-21...
**
** b10
**
** 07-01-22 rri - Set Version[]="DiskMaster 2.7b10"
**              - Set date to 2007-01-28 for next scheduled release.
**
** 07-01-28 rri - Removed init of not used "ScrollerBase" from the 68k-build.
**
** 07-02-04 rri - Added init of Input.device.
**              - Set release-date to 2007-02-04.
**
** b11
**
** 07-02-27 rri - Set Version[]="DiskMaster 2.7b11"
**              - Set date to 2007-02-27 to send A.Hucko a test-version.
**
** 07-03-01 rri - Set date to 2007-03-01 to send A.Hucko a test-version.
**
** 07-03-03 rri - Set release-date to 2007-03-04.
**
** b12
**
** 07-03-10 rri - Set Version[]="DiskMaster 2.7b12"
**              - Set release-date to 2007-03-10 - just for starters.
**
** 08-08-29 rri - Set release-date to 2008-08-29
**              - Set Version[]="DiskMaster 2.7b12test"
**
**
**
**
*/


#include "DM.h"

#ifdef __amigaos4__
#define STACKSIZE 18000 /* 2.5.28 */
#else
#define STACKSIZE 9000 /* 2.5.24 */
#endif

#include <libraries/locale.h> /* 2.5RC4 rri */
#include <proto/locale.h> /* 2.5RC4 rri */

/* #include <proto/commodities.h> - added for a test, might become usefull... */

extern struct Menu      *DMMenu;
extern struct RexxMsg   *WaitRX;

extern UBYTE *Globuff, /* 2.5b9 rri */
             sbuff[],
             dcPath[]; /* 2.7b8 rri */

extern STRPTR AppIconPath; /* 2.7 rri */


extern LONG Notify; /* 2.5.23 rri */

extern struct TagItem reqtags_Ok[],            /* 2.5b13 jjt */
                      reqtags_OkSkipCan[],     /* 2.5b13 jjt */
                      reqtags_HelpOk[],        /* 2.6 jjt */
                      reqtags_HelpOkSkipCan[]; /* 2.6 jjt */

extern struct TextAttr DMTextAttrs[], /* 2.7 rri */
                       Default_TAttr; /* 2.5.31 rri */

extern struct SignalSemaphore ViewA_Semaphore;  /* 2.6 jjt*/

extern struct DirInfo DInfo; /* 2.7 rri */

struct Library       * AslBase;
struct Library       * DiskfontBase;
struct Library       * GadToolsBase; /* 2.5RC4 rri */
struct Library       * IconBase; /* 2.5RC4 rri */
struct Library       * WorkbenchBase;
/*struct Library       * CxBase; - added for a test, might become usefull... */
struct Library       * LayersBase; /* 2.7b8 rri */

#ifdef __amigaos4__ /* 2.5.31 rri */
struct Library       * GfxBase;
struct Library       * IntuitionBase;
struct Library       * LocaleBase;
struct Library       * RexxSysBase;
struct Library       * UtilityBase;
#else
struct GfxBase       * GfxBase; /* 2.5RC4 rri */
struct IntuitionBase * IntuitionBase; /* 2.5RC4 rri */
struct LocaleBase    * LocaleBase; /* 2.5RC4 rri */
struct RxsLib        * RexxSysBase;
struct UtilityBase   * UtilityBase; /* 2.5.29 rri */
/*struct Library       * UtilityBase;*/ /*jjt KLUDGE*/
#endif

/* Reaction classes */  /* 2.6 jjt */
struct Library * WindowBase = NULL;
struct Library * LayoutBase = NULL;
struct Library * LabelBase = NULL;
struct Library * ButtonBase = NULL;
struct Library * StringBase = NULL;
struct Library * ChooserBase = NULL;
/* 2.6 rri */
struct Library * ClickTabBase = NULL;
struct Library * GetScreenModeBase = NULL;
struct Library * CheckBoxBase = NULL;
struct Library * IntegerBase = NULL;
struct Library * GetFileBase = NULL;
struct Library * GetFontBase = NULL;  /* 2.6 jjt */
struct Library * PaletteBase = NULL;  /* 2.6 jjt */
struct Library * SliderBase = NULL;   /* 2.6 jjt */

struct Library * ListBrowserBase = NULL; /* 2.7 jjt */
//struct Library * ScrollerBase = NULL; /* 2.7 rri */

struct Device  * TimerBase; /* 2.5RC4 rri */ /* 2.5RC9 rri */
struct Library  * InputBase; /* 2.7b10 rri */

struct Library * BevelBase = NULL; /* 2.7 rri */

struct Library       *LibBasePtrs[30]; /* 2.6 rri */

/* OS4/GCC/clib2 specific settings */
#ifdef __amigaos4__ /*2.5.31 rri */
char * __stdio_window_specification = "NIL:"; /* no default stdout-window */
#endif


#ifdef __amigaos4__ /* 2.5.26 rri */
struct WorkbenchIFace  * IWorkbench = NULL;
struct DiskfontIFace   * IDiskfont = NULL;
struct AslIFace        * IAsl = NULL;
struct RexxSysIFace    * IRexxSys = NULL;
struct LocaleIFace     * ILocale = NULL;
struct GraphicsIFace   * IGraphics = NULL;
struct GadToolsIFace   * IGadTools = NULL;
struct IntuitionIFace  * IIntuition = NULL;
struct IconIFace       * IIcon = NULL;

#ifndef __NEWLIB__ /* 2.7 rri */
struct UtilityIFace    * IUtility = NULL;
#endif
/* struct CommoditiesIFace *ICommodities = NULL; - added for a test, might become usefull... */

struct LayersIFace     * ILayers = NULL; /* 2.7b8 rri */
struct WindowIFace     * IWindow = NULL;
struct LayoutIFace     * ILayout = NULL;
struct LabelIFace      * ILabel = NULL;
struct ButtonIFace     * IButton = NULL;
struct StringIFace     * IString = NULL;
struct ChooserIFace    * IChooser = NULL;
struct CheckBoxIFace      *ICheckBox = NULL;
struct ClickTabIFace      *IClickTab = NULL;
struct GetFileIFace       *IGetFile = NULL;
struct GetScreenModeIFace *IGetScreenMode = NULL;
struct IntegerIFace       *IInteger = NULL;
struct GetFontIFace       *IGetFont = NULL;  /* 2.6 jjt */
struct PaletteIFace       *IPalette = NULL;  /* 2.6 jjt */
struct SliderIFace        *ISlider = NULL;   /* 2.6 jjt */

struct ListBrowserIFace   *IListBrowser = NULL; /* 2.7 jjt */
//struct ScrollerIFace      *IScroller = NULL; /* 2.7 rri */

struct Interface       * IFacePtrs[30]; /* 2.6 rri */

struct TimerIFace      * ITimer = NULL;
struct BevelIFace      * IBevel = NULL; /* 2.7 rri */

struct InputIFace      * IInput = NULL; /* 2.7b10 rri */

#endif


struct Screen    *Screen;
struct Process   *process;

struct MsgPort   *NotifyPort=0, /* 2.5b7 rri */
                 *TimerPort=0, /* 2.5.23 rri */
                 *InputPort=0, /* 2.7b10 rri */
                 *WinPort=0;

struct DirWindow *DirWin[DMMAXWINDOWS],*CDWin,*DestWin,*CmdWin; /* 2.5.23 rri */
struct DirList   *DClickDir;
struct StringHistory ReqHistory, PathHistory, ReadHistory, /* 2.5b10 jjt */
       CmdHistory; /* 2.6 */
struct Hook EditHook;  /* 2.5b10 jjt */
struct TextFont *DMFonts[DMFONTS_COUNT];  /* 2.5RC2 jjt */

struct TimeRequest *TimerIO; /* 2.7b7 rri */
struct IORequest *InputIO; /* 2.7b10 rri */

struct StackSwapStruct DM2StackSwap; /* 2.5.24 rri */

struct PathList /* from: "The Amiga Guru Book", p.571 */
{
 BPTR nextPath; /* BPTR to struct PathList */
 BPTR pathLock; /* BPTR to struct FileLock */
};

APTR CommentPool=0, /* 2.5b10 rri */
     NamePool=0, /* 2.5b10 rri */
     StringPool=0, /* 2.5b10 jjt */
     ReaderPool=0; /* 2.5b10 jjt */

int returncode=0; /* 2.5.24 rri */

LONG DMnumber=2, /* 2.5RC4 rri - vbcc */
     LibBaseTotal=0, /* 2.5b6 jjt (18.5.00) */
#ifndef __amigaos4__
     long_month=0, /* 2.5RC6 rri */
#endif
     lockcount; /* 2.5.23 rri */

ULONG FLAGS=DMFLAG_KEEPGOING; /* 2.5RC6 rri */

char  BarFormat[192], /* 2.5RC10 rri */
      DispFormat[22], /* 2.5RC10 rri */
      PGadStr[256],
      ScreenTitle[256],
      TitleFormat[52], /* 2.5RC10 rri */
      Version[]="DiskMaster 2.7b12test",
      VerstrA[]="\0$VER: DiskMaster 2.7 (29.08.2008) R.Riedel"; /* changed format - 2.6 rri */

STRPTR DiskMaster2Guide, /* 2.6 jjt */
       ProgName,        /* 2.7 rri */
       shellarg = NULL; /* 2.7 rri */

char DMname[7]="DM.1"; /* 2.7 rri */


LONG InitLibsPortsPools(void); /* 2.5.23 rri */
void StartTimer(uint32 itime); /* 2.7b7 rri */
int DM2main(void); /* 2.5.24 rri */


/* 2.5.24 rri */
int main(int argc, char *argv[])
{
struct WBStartup *Wbs;
ULONG *DM2Stack;

process=(struct Process *)FindTask(NULL);

if(argc!=0) /* started from CLI */
 {
  ProgName=argv[0];
  shellarg=argv[1];
 }
else /* started from WB */
 {
  Wbs = (struct WBStartup *) argv;

  /* 2.5.26 rri */
  if(process->pr_CLI==0) /* it should always be ZERO but this could */
   {                     /* change in the future...                 */
    struct CommandLineInterface *DestCLI;
    BPTR pathList;
#ifdef __amigaos4__ /* 2.5.26 rri */
    if (LibOpen("workbench", &WorkbenchBase, 44, (uint32) &IWorkbench)) /* 2.5.31 rri */
#else
    if (LibOpen("workbench", &WorkbenchBase, 44)) /* we need OS3.5... */
#endif
     {
      if(WorkbenchControl(NULL, WBCTRLA_DuplicateSearchPath, &pathList, TAG_DONE))
       {
        if((DestCLI = AllocDosObject(DOS_CLI,NULL)))
         {
          process->pr_CLI    = MKBADDR(DestCLI);
          process->pr_Flags |= PRF_FREECLI; /* mark for cleanup */
          DestCLI->cli_CommandDir = pathList;
         }
       }
     }
   }
  ProgName=Wbs->sm_ArgList[0].wa_Name;
  if(Wbs->sm_NumArgs>1)
   {
    shellarg=Wbs->sm_ArgList[1].wa_Name;
   }
 }

if(((ULONG)process->pr_Task.tc_SPUpper-(ULONG)process->pr_Task.tc_SPLower)<STACKSIZE)
 {
  if((DM2Stack=AllocVec(STACKSIZE,MEMF_ANY | MEMF_CLEAR))) /* 2.5.28 rri */
   {
    DM2StackSwap.stk_Lower = DM2Stack;
    DM2StackSwap.stk_Upper = (ULONG)DM2Stack+STACKSIZE;
    DM2StackSwap.stk_Pointer=(void *)(DM2StackSwap.stk_Upper-32);
    StackSwap(&DM2StackSwap);
    returncode=DM2main();
    StackSwap(&DM2StackSwap);
    FreeVec(DM2Stack);
   }
  return(returncode);
 }
else
 {
  returncode=DM2main(); /* 2.5.31 rri */
 }

return(returncode);
}


int DM2main(void) /* 2.5.24 rri */
{
LONG i; /* 2.5.23 rri */
#ifndef __amigaos4__
struct DateTime DateTime; /* 2.5RC6 rri */
char Date[16]; /* 2.7 rri */
#endif
STRPTR ShellName; /* 2.7 rri */

Forbid();
while(FindPort(DMname))
 {
  sprintf (DMname,"DM.%ld", DMnumber++);
 }
Permit();

/* test!
if(process->pr_CLI)
 {
  struct CommandLineInterface *SourceCLI;
  if(SourceCLI = BADDR(process->pr_CLI))
   {
    struct PathList *xxx;
    kprintf("Path-List:\n");
    xxx = BADDR(SourceCLI->cli_CommandDir);
    while(xxx)
     {
      NameFromLock(xxx->pathLock,sbuff,512);
      kprintf("%s\n",sbuff);
      xxx = BADDR(xxx->nextPath);
     }
    kprintf("\n");
   }
 }
*/

DMnumber--;
ShellName=process->pr_Task.tc_Node.ln_Name; /* save the name pointer for the shell */ /* 2.5.23 rri */
process->pr_Task.tc_Node.ln_Name=DMname;

/* --- init of optional libs: --- */

#ifdef __amigaos4__ /* 2.5.26 rri */

LibOpen("rexxsyslib", (struct Library **) &RexxSysBase, 45,(uint32) &IRexxSys); /* need V45+ for OS4 */  /* 2.5.31 rri */
LibOpen("diskfont", &DiskfontBase, 50, (uint32) &IDiskfont); /* 2.6 rri */
LibOpen("asl", &AslBase, 50, (uint32) &IAsl); /* 2.6 rri */
if (LibOpen("locale", (struct Library **) &LocaleBase, 50, (uint32) &ILocale)) /* 2.6 rri */
 {
  OpenDiskMaster2Catalog(); /* 2.6 rri */
 }


#else
LibOpen("rexxsyslib", (struct Library **) &RexxSysBase, 0);  /* 2.5b6 jjt (18.5.00) */
LibOpen("diskfont", &DiskfontBase, 0);                       /* 2.5b6 jjt (18.5.00) */
LibOpen("asl", &AslBase, 39);                                /* 2.5.31 rri */
if (LibOpen("locale", (struct Library **) &LocaleBase, 39)) /* 2.5.31 rri */
 {
  OpenDiskMaster2Catalog(); /* 2.6 rri */
 }
#endif

/* --- Initialize reqtags_... strings --- */
reqtags_Ok[0].ti_Data = (ULONG) msgGadOkay;             /* 2.5b13 jjt */
reqtags_OkSkipCan[0].ti_Data = (ULONG) msgGadOkSkipCan; /* 2.5b13 jjt */
reqtags_HelpOk[1].ti_Data = (ULONG) msgGadOkay;           /* 2.6 jjt */
reqtags_HelpOkSkipCan[1].ti_Data = (ULONG) msgGadOkSkipCan; /* 2.6 jjt */

/* --- var ini on startup --- */
strcpy (PGadStr,"Parent");
sprintf (DispFormat,"N S C"); /* 2.5RC8 rri */

/* 2.7 rri */
DInfo.num = 3;
DInfo.titles[0] = (STRPTR) msgListerName; /* 2.7b9 rri */
DInfo.sorting[0] = 0;
DInfo.titles[1] = (STRPTR) msgListerSize; /* 2.7b9 rri */
DInfo.sorting[0] = 2;
DInfo.titles[2] = (STRPTR) msgListerComment; /* 2.7b9 rri */
DInfo.sorting[0] = 6;

sprintf (TitleFormat,"%%B/%%F %%I/%%C");
sprintf (BarFormat,"DiskMaster %%V  %%T   C:%%C  F:%%F  Total:%%P"); /* 2.5b9 rri */

/* --- check if months have to be displayed with four chars --- 2.5RC6 rri */
#ifndef __amigaos4__
DateTime.dat_Stamp.ds_Days = 160; /* 1978-Jun-10 */
DateTime.dat_Stamp.ds_Minute = 0;
DateTime.dat_Stamp.ds_Tick = 20; /* shortly after midnight... */
DateTime.dat_Format  = FORMAT_INT; /* yy-mmm-dd e.g. 00-Jul-13 */
DateTime.dat_Flags   = 0;
DateTime.dat_StrDay  = 0;
DateTime.dat_StrDate = Date;
DateTime.dat_StrTime = 0;
DateToStr(&DateTime);
if(Date[6]!='-') long_month = 1;
#endif

#ifdef __amigaos4__ /* 2.5.31 rri */
FLAGS|=DMFLAG_USE30; /* this is compiled for OS4, won't run on anything less anyways... */
#else
if( (SysBase->LibNode.lib_Version) > 38) FLAGS|=DMFLAG_USE30; /* 2.5RC9 rri */
#endif


if(InitLibsPortsPools()) /* 2.5RC9 rri */
 {
  TimerBase = TimerIO->Request.io_Device; /* 2.7b7 rri */
  InputBase = (struct Library *) InputIO->io_Device; /* 2.7b10 rri */

  /* 2.7b8 rri - support for AmiUpdate */
#ifdef __amigaos4__
  DevNameFromLock( GetProgramDir(), dcPath, 4000, DN_FULLPATH);
#else
  NameFromLock( GetProgramDir(), dcPath, 4000);
#endif
  SetVar("AppPaths/DiskMaster2",dcPath, -1, GVF_GLOBAL_ONLY|GVF_SAVE_VAR);
/* this one checks the path before overwriting it but actully causes more overhead in total
  int32 varlen;

  varlen = GetVar("AppPaths/DiskMaster2",sbuff,4000,0);
  if (varlen == -1 || (varlen != -1 && Stricmp(sbuff,dcPath) != 0) )
  {
   SetVar("AppPaths/DiskMaster2",dcPath, -1, GVF_GLOBAL_ONLY|GVF_SAVE_VAR);
  }
*/

  InitScreenDefaults();

  for (i=0; i < DMFONTS_COUNT; i++) /* 2.5.31 rri */
   {
    if (i==DMFONTS_READER) /* 2.7 rri */
     {
      if (DMTextAttrs[DMFONTS_SCREEN].ta_Flags & FPF_PROPORTIONAL) /* 2.7 rri */
       {
        DMFonts[i] = OpenFont(&Default_TAttr);
        continue;
       }
     }
    DMFonts[i] = OpenFont(&DMTextAttrs[DMFONTS_SCREEN]); /* 2.7 rri */
   }

  /* 2.7 rri - from DMPreferences.c */
  /* Fill in TextAttrs for the DMFonts up to but excluding DMFONTS_SCREEN */
  for (i=0; i < (DMFONTS_SCREEN); i++)
  {
   FontToAttr(DMFonts[i], &(DMTextAttrs[i]));
  }

  AppIconPath=CloneStr(ProgName,StringPool); /* 2.5.26 rri */

#ifdef __amigaos4__ /* 2.5.26 rri */
  EditHook.h_Entry = StringHook;
#else
  EditHook.h_Entry = (ULONG (*)()) StringHook;
#endif

  StrHist_Init(&ReqHistory);         /* 2.5b10 jjt */
  StrHist_Init(&PathHistory);        /* 2.5b10 jjt */
  StrHist_Init(&ReadHistory);        /* 2.5b10 jjt */
  StrHist_Init(&CmdHistory);         /* 2.6 jjt */
  ReadHistory.mempool = ReaderPool;  /* 2.6 jjt */

  InitSemaphore(&ViewA_Semaphore);
  DiskMaster2Guide = CloneStr("PROGDIR:DiskMaster2.guide", StringPool);

  for(i=0;i<DMMAXWINDOWS;i++) DirWin[i]=NULL; /* 2.5.23 rri */

  if(BootBatch((UBYTE *) shellarg)) /* 2.7 rri */
   {
    /* 2.7 rri */
/* test!
    Forbid();
    if(!FindPort(DMname))
     {
      Printf("doing AddPort() now...\n"); // test!
      AddPort(WinPort);
     }
    Permit();
*/

    DoWindow();

    while(FLAGS&DMFLAG_KEEPGOING) /* 2.5RC2 rri */
     {
      MainLoop(); /* 2.5b9 rri */
     }
   }

  FreeUserData(); /* 2.5RC10 rri */

  FLAGS&=~DMFLAG_KEEPGOING; /* 2.5RC2 rri */
 }

if(WinPort)
 {
  /* 2.7 rri */
  if (FindPort(DMname)) /* check if port is installed */
   {
    struct Message *msg;

    while((msg=GetMsg(WinPort))) /* clear port */
     {
      ReplyMsg(msg);
     }
    RemPort(WinPort); /* shut-down port! */
   }
  DeletePort(WinPort); /* 2.5RC10 rri */
 }

if(NotifyPort) DeletePort(NotifyPort); /* 2.5RC10 rri */

/* 2.5.31 rri */
if(CommentPool) DeletePool(CommentPool);
if(NamePool   ) DeletePool(NamePool   );
if(StringPool ) DeletePool(StringPool );
if(ReaderPool ) DeletePool(ReaderPool );


for (i=0; i < DMFONTS_COUNT; i++) /* 2.5RC2 jjt */
 {
  if (DMFonts[i])
   {
    CloseFont(DMFonts[i]);
    DMFonts[i] = NULL;
   }
 }

if(TimerBase) /* 2.5.26 rri */
 {
  if(CheckIO(&TimerIO->Request) == 0) /* 2.7b7 rri */
   {
    AbortIO(&TimerIO->Request); /* 2.7b7 rri */
    WaitIO(&TimerIO->Request); /* 2.7b7 rri */
   }
  #ifdef __amigaos4__ /* 2.5.26 rri */
  DropInterface((struct Interface *)ITimer);
  #endif
  CloseDevice((struct IORequest *)TimerIO);
  DeleteIORequest((struct IORequest *) TimerIO); /* 2.5.26 rri */
 }

if(TimerPort)  DeletePort(TimerPort); /* 2.5.23 rri */


/* 2.7b10 rri */
if(InputBase)
 {
  if(CheckIO(InputIO) == 0)
   {
    AbortIO(InputIO);
    WaitIO(InputIO);
   }
  #ifdef __amigaos4__
  DropInterface((struct Interface *)IInput);
  #endif
  CloseDevice(InputIO);
  DeleteIORequest(InputIO);
 }

if(InputPort)  DeletePort(InputPort);


CloseDiskMaster2Catalog(); /* 2.6 rri */

for (i=0; i < LibBaseTotal; i++)
 {
  #ifdef __amigaos4__ /* 2.5.26 rri */
  DropInterface(IFacePtrs[i]);
  #endif
  CloseLibrary(LibBasePtrs[i]);  /* 2.5b6 jjt (18.5.00) */
 }
process->pr_Task.tc_Node.ln_Name=ShellName; /* restore the shell's name pointer */ /* 2.5.23 rri */
return 1;
}


LONG InitLibsPortsPools(void) /* 2.5.23 rri */
{
if(
#ifdef __amigaos4__ /* 2.5.26 rri */
    ( LibOpen("graphics", (struct Library **) &GfxBase, 52, (uint32) &IGraphics) ) /* 2.5.31 rri */
 && ( LibOpen("layers", (struct Library **) &LayersBase, 52, (uint32) &ILayers) ) /* 2.7b8 rri */
#ifndef __NEWLIB__ /* 2.7 rri */
 && ( LibOpen("utility", (struct Library **) &UtilityBase, 52, (uint32) &IUtility) ) /* 2.6 rri */
#endif
 && ( LibOpen("gadtools", &GadToolsBase, 52, (uint32) &IGadTools) ) /* 2.6 rri */
 && ( LibOpen("intuition", (struct Library **) &IntuitionBase, 52, (uint32) &IIntuition) ) /* 2.6 rri */
 && ( LibOpen("icon", &IconBase, 52, (uint32) &IIcon ) ) /* 2.6 rri */
 /* 2.6 rri */
 && ( LibOpen("window.class", &WindowBase, 52, (uint32) &IWindow) )
 && ( LibOpen("gadgets/layout.gadget", &LayoutBase, 52, (uint32) &ILayout) )
 && ( LibOpen("images/label.image", &LabelBase, 52, (uint32) &ILabel) )
 && ( LibOpen("images/bevel.image", &BevelBase, 52, (uint32) &IBevel) ) /* 2.7 rri */
 && ( LibOpen("gadgets/string.gadget", &StringBase, 52, (uint32) &IString) )
 && ( LibOpen("gadgets/button.gadget", &ButtonBase, 52, (uint32) &IButton) )
 && ( LibOpen("gadgets/chooser.gadget", &ChooserBase, 52, (uint32) &IChooser) )
 && ( LibOpen("gadgets/clicktab.gadget", &ClickTabBase, 52, (uint32) &IClickTab) )
 && ( LibOpen("gadgets/getscreenmode.gadget", &GetScreenModeBase, 52, (uint32) &IGetScreenMode) )
 && ( LibOpen("gadgets/checkbox.gadget", &CheckBoxBase, 52, (uint32) &ICheckBox) )
 && ( LibOpen("gadgets/integer.gadget", &IntegerBase, 52, (uint32) &IInteger) )
 && ( LibOpen("gadgets/getfile.gadget", &GetFileBase, 52, (uint32) &IGetFile) )
 && ( LibOpen("gadgets/getfont.gadget", &GetFontBase, 52, (uint32) &IGetFont) )  /* 2.6 jjt */
 && ( LibOpen("gadgets/palette.gadget", &PaletteBase, 52, (uint32) &IPalette) )  /* 2.6 jjt */
 && ( LibOpen("gadgets/slider.gadget", &SliderBase, 52, (uint32) &ISlider) )  /* 2.6 jjt */
 && ( LibOpen("gadgets/listbrowser.gadget", &ListBrowserBase, 52, (uint32) &IListBrowser) )  /* 2.7 jjt */
// && ( LibOpen("gadgets/scroller.gadget", &ScrollerBase, 52, (uint32) &IScroller) ) /* 2.7 rri */

#else
    ( LibOpen("graphics", (struct Library **) &GfxBase, 39) ) /* 2.5.31 rri */
 && ( LibOpen("layers", (struct Library **) &LayersBase, 39 ) ) /* 2.6 rri */
 && ( LibOpen("utility", (struct Library **) &UtilityBase, 39) ) /* 2.5.31 rri */
 && ( LibOpen("gadtools", &GadToolsBase, 39) ) /* 2.5.31 */
 && ( LibOpen("intuition", (struct Library **) &IntuitionBase, 39) ) /* 2.5.31 rri */
 && ( LibOpen("icon", &IconBase, 39) ) /* 2.5.31 rri */
 && ( LibOpen("window.class", &WindowBase, 41) )            /* 2.6 jjt */
 && ( LibOpen("gadgets/layout.gadget", &LayoutBase, 41) )   /* 2.6 jjt */
 && ( LibOpen("images/label.image", &LabelBase, 41) )       /* 2.6 jjt */
 && ( LibOpen("images/bevel.image", &BevelBase, 41) )       /* 2.7 rri */
 && ( LibOpen("gadgets/string.gadget", &StringBase, 41) )   /* 2.6 jjt */
 && ( LibOpen("gadgets/button.gadget", &ButtonBase, 41) )   /* 2.6 jjt */
 && ( LibOpen("gadgets/chooser.gadget", &ChooserBase, 41) ) /* 2.6 jjt */
 /* 2.6 rri */
 && ( LibOpen("gadgets/clicktab.gadget", &ClickTabBase, 41) )
 && ( LibOpen("gadgets/getscreenmode.gadget", &GetScreenModeBase, 41) )
 && ( LibOpen("gadgets/checkbox.gadget", &CheckBoxBase, 41) )
 && ( LibOpen("gadgets/integer.gadget", &IntegerBase, 41) )
 && ( LibOpen("gadgets/getfile.gadget", &GetFileBase, 41) )
 && ( LibOpen("gadgets/getfont.gadget", &GetFontBase, 41) )  /* 2.6 jjt */
 && ( LibOpen("gadgets/palette.gadget", &PaletteBase, 41) )  /* 2.6 jjt */
 && ( LibOpen("gadgets/slider.gadget", &SliderBase, 41) )  /* 2.6 jjt */
 && ( LibOpen("gadgets/listbrowser.gadget", &ListBrowserBase, 41) )  /* 2.7 jjt */
// && ( LibOpen("gadgets/scroller.gadget", &ScrollerBase, 41) ) /* 2.7 rri */

#endif

 && ( WinPort=CreatePort(DMname,2) ) /* 2.5RC10 rri */
 && ( NotifyPort=CreatePort(0,0) )

 /* 2.5.23 rri */
 && ( TimerPort=CreatePort(0,0) )
 && ( TimerIO=(struct TimeRequest *)CreateIORequest(TimerPort,sizeof(struct TimeRequest)) ) /* 2.7b7 rri */
 && ( OpenDevice("timer.device",UNIT_VBLANK,&TimerIO->Request,0) == 0 ) /* 2.7b7 rri */

 /* 2.7b10 rri */
 && ( InputPort=CreatePort(0,0) )
 && ( InputIO=CreateIORequest(InputPort,sizeof(struct IORequest)) )
 && ( OpenDevice("input.device",0,InputIO,0) == 0 )

#ifdef __amigaos4__ /* 2.5.26 rri */
 && ( ITimer=(struct TimerIFace *)GetInterface((struct Library *) TimerIO->Request.io_Device, "main", 1, NULL) ) /* 2.7b7 rri */
 && ( IInput=(struct InputIFace *)GetInterface((struct Library *) InputIO->io_Device, "main", 1, NULL) ) /* 2.7b10 rri */
#endif

/* 2.5.31 rri */
 && ( CommentPool= CreatePool(MEMF_ANY | MEMF_CLEAR,  8100,  100 ) ) /* 2.5.28 rri */
 && ( NamePool   = CreatePool(MEMF_ANY | MEMF_CLEAR, 16384, 1024 ) ) /* 2.5.28 rri */
 && ( StringPool = CreatePool(MEMF_ANY | MEMF_CLEAR, 20000, 2000 ) ) /* 2.5.28 rri */
 && ( ReaderPool = CreatePool(MEMF_ANY | MEMF_CLEAR,  1200, 1000 ) ) /* 2.5.28 rri */
  )
 {
  return 1;
 }
return 0;
}

#ifdef __amigaos4__ /* 2.5.26 rri */
BOOL LibOpen(STRPTR name, struct Library **base, ULONG ver, uint32 xface) /* 2.5.31 rri */
{
struct Interface **iface = (struct Interface **) xface;

if (*base == 0)
 {
  char puffer[120]; /* 2.7 rri */

  if (strchr(name, '.')) /* 2.6 jjt */
   {
    /* Reaction libs already have an extension. */
    strcpy(puffer, name);
   }
  else
   {
    /* Append ".library" to <name>, as usual */
    sprintf(puffer,"%s.library",name);
   }
  if ((*base = OpenLibrary(puffer, ver)) == 0) return FALSE;
  LibBasePtrs[LibBaseTotal] = *base;
  if ((*iface = GetInterface(*base, "main", 1, NULL)) == 0)
   {
    CloseLibrary(*base);
    *base=NULL;
    LibBasePtrs[LibBaseTotal]=NULL;
    return FALSE;
   }
  IFacePtrs[LibBaseTotal++] = *iface;
 }
return TRUE;
}

#else
BOOL LibOpen(STRPTR name, struct Library **base, ULONG ver) /* 2.5b6 jjt */
{
if (*base == 0)
 {
  UBYTE puffer[120]; /* 2.5RC6 rri */

  if (strchr(name, '.')) /* 2.6 jjt */
   {
    /* Reaction libs already have an extension. */
    strcpy(puffer, name);
   }
  else
   {
    /* Append ".library" to <name>, as usual */
    sprintf(puffer,"%s.library",name); /* 2.5RC6 rri*/
   }

  if ((*base = OpenLibrary(puffer, ver)) == 0)
   {
/* test! 2.6 rri - not activated because it is an annoyance with optional components
    struct EasyStruct warnES;

    warnES.es_StructSize = sizeof(struct EasyStruct);
    warnES.es_Flags = NULL;
    warnES.es_Title = Version;
    warnES.es_GadgetFormat = (UBYTE *) msgGadOkay;
    warnES.es_TextFormat = puffer;

    if(strcmp (name, "intuition") != 0)
     {
      LibOpen("intuition", (struct Library **) &IntuitionBase, 39);
     }

    if(IntuitionBase) EasyRequest(NULL, &warnES, NULL, NULL);
*/
    return FALSE;
   }
  LibBasePtrs[LibBaseTotal++] = *base;
 }
return TRUE;
}
#endif


void MainLoop(void) /* 2.5b9 rri */
{
struct DirWindow *dw;
LONG t,i,wincount; /* 2.5.23 rri */
ULONG sig;
ULONG notifymask = 1L << NotifyPort->mp_SigBit; /* 2.5b7 rri */
ULONG timermask = 1L << TimerPort->mp_SigBit; /* 2.5.23 rri */
ULONG winmask = 1L << WinPort->mp_SigBit; /* 2.5.23 rri */
struct NotifyMessage *note; /* 2.5b7 rri */
struct DateStamp now;
static uint32 itime=1; /* 2.7b7 rri */
static LONG Minutes=0;

if(lockcount) /* a dir-window is busy */
 {
  t=0;
  for(i=0;i<DMMAXWINDOWS;i++) /* 2.5.23 rri */
   {
    dw=DirWin[i];
    if(dw) GetDirEntry(dw);
    if(dw&&dw->DirLock) t=1;
   }
  if(!t)
   {
    lockcount=0;
    if(WaitRX)
     {
      ReplyMsg((struct Message *)WaitRX);
      WaitRX=0;
     }
   }
  DoWindow();
 }

else /* waiting for some action... */
 {
  StartTimer(itime); /* 2.5.23 rri */
  sig=Wait(winmask|notifymask|timermask); /* 2.5.23 rri */

  /* always break TimerIO and clear signal */ /* 2.5.23 rri */
  AbortIO(&TimerIO->Request); /* 2.7 rri */
  WaitIO(&TimerIO->Request); /*2.7 rri */
  SetSignal(0L,timermask);

  if(sig & winmask) /* 2.5.23 rri */
   {
    MainTitle();
    DoWindow();
   }

  if (sig & notifymask) /* 2.5b7 rri */
   {
    while((note=(struct NotifyMessage *)GetMsg(NotifyPort))) /* 2.5.23 gcc rri */
     {
      ReplyMsg((struct Message *)note);
     }
    ReSort(); /* 2.5b7 rri */
   }

  if(sig & timermask) /* 2.5.23 rri */
   {
    wincount=0; /* 2.5b3 rri */
    while(DirWin[wincount])
     {
      if(DirWin[wincount]->Window->Flags&WFLG_WINDOWACTIVE)
       {
        itime=1+Notify; /* 2.5b9 rri */
        break;   /* 2.5b6 jjt (11.6.00) */
       }
      else
       {
        itime=4;
        wincount++;
       }
      }

    DClickDir=0;

    if(CDWin) /* 2.5b3 rri */
     {
      DateStamp(&now); /* get current system time */
      if (now.ds_Minute>Minutes) /* check if a new minute began */
       {
        Minutes=now.ds_Minute; /* update the minute-counter var */
        MainTitle(); /* 2.5b2 rri */
        SetTitles(); /* 2.5b2 rri */
       }
      if(!(CDWin->dwgad[GID_String]->Flags&GFLG_SELECTED)) /* 2.7b7 rri */
       {
        ReSort();
       }
     }
   }
 }
}


void StartTimer(uint32 itime) /* 2.7b7 rri */
{
TimerIO->Time.Seconds = itime;
TimerIO->Time.Microseconds = 0;
TimerIO->Request.io_Command=TR_ADDREQUEST;

SendIO(&TimerIO->Request);
}

