/* DiskMaster2 requester module
**
** 2.5.29
**
** 04-04-04 jjt - Bugfix: In case the string-history buffer was full cycling thru it by pressing
**                        cursor-down did not stop at the last entry but restarted.
**                        Thanks for reporting to Glenn Edward <glenn_edw@email.com>!
**
** 2.5.30
**
** 04-04-10 jjt - Bugfix: DMReqTagList() - Replaced the WA_Gadgets line with an AddGList later
**                        in the routine.  Eliminates the gadgets from being drawn, erased, and
**                        redrawn.  May also provide an infinesessimal performance boost. :-)
**                        Thanks for reporting to Glenn Edward <glenn_edw@email.com>!
**
** 04-05-19 jjt - Bugfix: DMReqTagList() - IDCMP_RAWKEY & IDCMP_VANILLAKEY events now handled
**                        in separate code blocks.  Prevents Rawkeys like Crsr-Left & F6 from
**                        being mistaken for hotkeys.
**                        Thanks for reporting to Glenn Edward <glenn_edw@email.com>!
** 2.5.31
**
** 04-10-12 rri - RexxSysBase is of type struct Library for OS4.
**
** 04-12-22 rri - Removed "use30" checking code - DM2 goes V39+!
**
** 05-03-26 rri - Changed "DM2" in about-requester to "DiskMaster2".
**
** 2.6
**
** 05-03-30 jjt - DMReqTagList() - Rewritten to use Reaction.
**              - strtoarray() - Removed RastPort and <widest> args.  No need to measure the
**                               pixel-length of strs anymore.
**              - MakeFReqGlyph() - Removed.
**              - FreeFReqGlyph() - Removed.
**
** 05-06-14 jjt - Moved Reaction libs' opening & closing to DM.c
**              - DMReqTagList() - Replaced nasty <body> '|' to/from LF code.
**                               - DMREQ_MINW is back.
**
** 05-06-18 rri - Fixed a few warnings with GCC 3.4.2 for OS4.
**
** 05-06-19 jjt - StringHook() - Added rawkey handling of Esc key.  Reaction string gadgets
**                               only notice Esc as a rawkey, regular gadgets only see it
**                               as vanilla 27.  [shriek!]
**              - DMReqTagList() - WHMI_GADGETUP - Catches Esc.
**              - Bugfix: DMReqTagList() - protection bits will not be changed if req. is
**                        canceled/aborted.
**              - Bugfix: StringHook(), DMReqTagList() - Dumb kludge to try to prevent
**                        multiple returns from being generated by the string gad.
**                        0.5 sec pause after pressing [Return] or [Enter].
**
** 05-06-22 jjt - Replaced the [Return] kludge of 05-06-19 with something nearly as dumb, but
**                more bulletproof.  Now the user should be able to fall asleep on the
**                [Return] key with no ill effects.
**
** 05-07-17 rri - Changed all references to "2.5.33" into "2.6".
**              - Removed comments from header older than 2.5.29.
**
** 05-07-17 jjt - Bugfix: DMReqTagList() - "GA_RelVerify, TRUE" in the string gadget creation code
**                was the source of the "repeating Returns" misery.  Removed it and the kludge code
**                from 2005-06-22 (good riddance!).
**
** 05-07-19 jjt - DMReqTagList() - Rewrote <body> '|' to LF code due to a suspected bug.  The bug
**                was actually elsewhere, but this compiles to a smaller exe, and looks nicer. :-)
**              - BugFix: StrHist_Init() - The strcache array is filled with zeros.  Chooser
**                gadgets need a null-terminated array.
**              - StrHist_Add(), StringHook() - Removed references to StringHistory.lencache.
**              - DMReqTagList() - Bugfix: Added CHOOSER_MaxLabels tag.  The chooser had been
**                using it's built-in limit of 12 items.
**
** 05-07-24 rri - Changed strtoarray() from using "UBYTE **strary" to "STRPTR *strary"
**                to be able to compile with OS4 SDK 51.10 again.
**
** 05-07-31 rri - Removed one unused var from DMReqTagList() to eliminate
**                one warning with GCC.
**              - Added a cast to a strtoarray() call to eliminate one
**                warning with GCC.
**
** 05-08-11 jjt - Bugfix: DMReqTagList() - The first underscore in req. body behaved as a
**                shortcut ID.  Added "IA_Underscore, 8,".
**
** 05-09-07 jjt - DMReqTagList() - Changed "WINDOW_Layout" tag to "WINDOW_ParentGroup".
**              - DMReqTagList() - Removed tests for valid DMFONTS_REQTXT and DMFONTS_REQBTN.
**                DM.c ensures they are always valid.
**
** 05-11-08 jjt - DMReqTagList() - Added DMREQ_HELPNODE option.
**              - Added reqtags_Help.  Functions can modify the first tagdata to get an
**                "Okay/Cancel" req. with help support.
**                Ex:  reqtags_Help[0].ti_Data = (LONG) "NodeName";
**
** 05-11-13 jjt - DMReqTagList() - DMREQ_HELPNODE defaults to "Main".
**              - DMReqTagList() - Added "Help" button.
**              - DMReqTagList() - DMREQ_PROTECT sets DMREQ_HELPNODE to "Protect".
**
** 05-11-14 jjt - DMReqTagList() - Finally found a halfway decent place for the Help
**                button:  to the right of the req. body text.
**              - DMReqTagList() - Renamed the Help button to "?".
**
** 05-11-21 jjt - REQ_FileExists() - Added DMREQ_HELPNODE to warntags.
**
** 05-11-22 jjt - DMReqTagList() - The Help button may be hidden by supplying the
**                DMREQ_NOHELPBTN tag (affects current req.), or by setting Req_HideHelpBtn
**                to FALSE (affects all reqs).
**              - CMD_Choose() - Sets DMREQ_NOHELPBTN.
**
** 05-11-23 jjt - Bugfix: DMReqTagList() -  The HELP key only worked when the req had a string
**                gadget.
**              - Added reqtags_HelpOk and reqtags_HelpOkSkipCan.  Like reqtags_Help, the
**                first tagdata is the help node, but the buttons are either "Okay" or
**                "Okay|Skip|Cancel" buttons.
**
** 05-11-26 jjt - DMReqTagList() - Chooser gadget won't be displayed if it isn't v45+.
**
** 05-11-30 jjt - DMReqTagList() - ClassAct compatible.
**                               - Removed 05-11-26's v45+ test.
**
** 05-12-01 jjt - DMReqTagList() - ClassAct - Added an extra ActivateGadget(), so that the
**                string gadget is active when the requester opens.
**
** 05-12-04 jjt - DMReqTagList() - Removed(?) a GCC warning.
**
** 05-12-07 jjt - DMReqTagList() - Help button uses req. body font.
**              - DMReqTagList() - Set the window's font to "bdyta" (body font).  Now it's
**                only necesary to specify a font when a different one is needed.
**
** 2.7
**
** 06-01-05 rri - Updated copyright notice for 2006
**
** b7
**
** 06-12-28 rri - Updated Busy() for use with a Window.class window.
**              - Replaced bdyta by DMTextAttrs[DMFONTS_REQTXT] and
**                btnta by DMTextAttrs[DMFONTS_REQBTN].
**
** 06-12-30 rri - Restored Intuition-window code for Busy().
**
** 07-01-02 rri - Set the year for the copyright-note to 2007.
**
** b9
**
** 07-01-17 rri - Removed the old-C-style init of desttime[] in REQ_FileExists().
**              - Replaced the old-C-style inits of btnstrs[] and protectgads[]
**                in DMReqTagList() by memset() calls.
**
** 07-01-21 rri - Replaced FORMAT_DOS by FORMAT_DEF in the file-exists-requester
**                with the result that the displayed dates are correctly localised now.
**
**
*/


#include "DM.h"


/* 2.5.26 jjt */
#define GID_FILEREQ 128

/* 2.6 jjt */
#define GID_PROTECT 129
#define GID_CHOOSER 130
#define GID_HELP    131


ULONG strtoarray(APTR mempool, CONST_STRPTR str, STRPTR *strary, ULONG arymax); /* 2.6 rri */
void  restorestrcontents(struct SGWork * swork);  /* 2.5b10 jjt */


extern UBYTE                Version[], ReqStr[], *rexxStr, /* 2.5b7 jjt (3.7.00) */
                            ActionArgs[],
                            sbuff[], /* 2.5b13 rri */
                            dcPath[]; /* 2.5.23 jjt */

extern ULONG                FLAGS, /* 2.5RC2 rri */
                            g_CommonWinFlags;  /* 2.5b10 jjt */

extern STRPTR               DiskMaster2Guide;  /* 2.6 jjt */

extern APTR                 StringPool; /* 2.5b10 jjt */
extern struct DirWindow     *DirWin[],*CDWin; /* new! 2.4b22 */

#ifdef __amigaos4__ /* 2.5.31 rri */
extern struct Library       *RexxSysBase;
#else
extern struct RxsLib        *RexxSysBase;
#endif

extern struct Screen        *Screen;
extern struct StringHistory ReqHistory, ReadHistory;  /* 2.5b10 jjt */
extern struct Hook          EditHook;  /* 2.5b10 jjt */
extern struct TextFont      *DMFonts[];  /* 2.5RC2 jjt */
extern struct TextAttr      DMTextAttrs[]; /* 2.7 rri */

extern ULONG  Screen_ID; /* 2.5.23 rri */

BOOL             Req_ShowHelpBtn=TRUE;  /* 2.6 jjt */
UBYTE            g_buttons[80]; /* 2.5b10 jjt */
LONG             busy; /* 2.5b7 rri */
struct Requester *Requester[DMMAXWINDOWS]; /* 2.5.26 rri */
/* Some often-used taglists   2.5b13 jjt */
struct TagItem reqtags_Ok[]={{DMREQ_BUTTONS,0}, /* 2.5.23 gcc rri */
                             {TAG_END,0}},      /* 2.5.23 gcc rri */
               reqtags_OkSkipCan[]={{DMREQ_BUTTONS,0}, /* 2.5.23 gcc rri */
                                    {DMREQ_ABORT,0},   /* 2.5.23 gcc rri */
                                    {TAG_END,0}},      /* 2.5.23 gcc rri */
               reqtags_Help[]={{DMREQ_HELPNODE, 0},         /* 2.6 jjt */
                               {TAG_END, 0}},
               reqtags_HelpOk[]={{DMREQ_HELPNODE, 0},       /* 2.6 jjt*/
                                 {DMREQ_BUTTONS,0},
                                 {TAG_END, 0}},
               reqtags_HelpOkSkipCan[]={{DMREQ_HELPNODE,0}, /* 2.6 jjt */
                                        {DMREQ_BUTTONS,0},
                                        {DMREQ_ABORT,0},
                                        {TAG_END,0}};


void Busy(int i) /* 2.5b7 rri */
{
ULONG a;

/* 2.5.31 rri */
if (i&&!busy)
 {
  for(a=0;a<DMMAXWINDOWS;a++) /* 2.5.23 gcc rri */
   {
    if (DirWin[a])
     {
//      SetAttrs(DirWin[a]->dwwindow,  WA_BusyPointer, TRUE, TAG_END); /* 2.7 rri */
//      busy=1;

      Requester[a]=(struct Requester *)AllocMem(sizeof(struct Requester), MEMF_ANY | MEMF_CLEAR);
      if (Requester[a])
       {
        if (Request(Requester[a],DirWin[a]->Window))
         {
          SetWindowPointer(DirWin[a]->Window,WA_BusyPointer, TRUE, TAG_DONE );
          busy=1;
         }
       }

     }
   }
 }

else if(!i&&busy)
 {
  for(a=0;a<DMMAXWINDOWS;a++) /* 2.5.23 gcc rri */
   {
    if (DirWin[a])
     {
//      SetAttrs(DirWin[a]->dwwindow,  WA_BusyPointer, FALSE, TAG_END); /* 2.7 rri */
//      busy=0;

      if (Requester[a])
       {
        SetWindowPointer (DirWin[a]->Window,TAG_DONE);
        EndRequest(Requester[a],DirWin[a]->Window);
        FreeMem((void *)(Requester[a]),sizeof(struct Requester));
        Requester[a]=0;
        busy=0;
       }

     }
   }
 }
}


void About()
{
sprintf(sbuff,"DiskMaster2\n\n" /* 2.5b13 rri */
              "Copyright (c) 1991-1997\n"
              " by Greg Cunningham\n\n"
              "Copyright (c) 1997-2007\n"
              " by Rudolph Riedel\n\n"
              "DiskMaster2 is mailware:\n" /* 2.5.31 rri */
              " Rudolph.Riedel@T-Online.de \n\n"
              "%s", msgReqAbout);

DMReqTagList(sbuff, 0, 0, reqtags_Ok);  /* 2.5b13 jjt */
}


LONG REQ_FileExists(sFIB *srcfib, sFIB *destfib) /* 2.5b13 jjt */
{
struct TagItem warntags[]={{DMREQ_BUTTONS,(ULONG) g_buttons},{DMREQ_ABORT,0},{DMREQ_HELPNODE,(ULONG)"xwarn"},{TAG_END,0}}; /* 2.5.28 rri */ /* 2.6 jjt */

UBYTE srcdate[20], srctime[10],
      destdate[20]={"Unknown"}, desttime[10]; /* 2.7b9 rri ={0}; */
LONG  ch, dsize=0;
struct DateTime dt;

dt.dat_Format = FORMAT_DEF; /* 2.7b9 rri FORMAT_DOS; */
dt.dat_Flags = 0;
dt.dat_StrDay = 0;

if(srcfib)
 {
  dt.dat_Stamp = srcfib->fib_Date;
  dt.dat_StrDate = srcdate;
  dt.dat_StrTime = srctime;
  DateToStr(&dt);
 }

if (destfib)
 {
  dt.dat_Stamp = destfib->fib_Date;
  dt.dat_StrDate = destdate;
  dt.dat_StrTime = desttime;
  DateToStr(&dt);
  dsize = destfib->fib_Size;
 }

if(srcfib)
 {
  sprintf(sbuff, msgReqFileExists, destfib->fib_FileName, /* 2.5b13 rri */
                                   srcfib->fib_Size, srcdate, srctime,
                                   dsize, destdate, desttime);
  warntags[0].ti_Data = (ULONG) msgGadOARSC; /* 2.5.26 rri */
  ch = DMReqTagList(sbuff, 0, 0, warntags); /* 2.5.26 rri */
 }
else /* 2.5.24 rri */
 {
  UBYTE *one=NULL;

  strcpy(sbuff,msgReqFileExists);
  for(ch=0;;ch++)
   {
    if(sbuff[ch] == 0x0a)
     {
      if(!one)
       {
        ch++;
        sbuff[ch] = 0;
        one=sbuff;
        continue;
       }
      else
       {
        one=sbuff+ch+1;
        break;
       }
     }
   }
  DMstrcat(sbuff,one);
  one = sbuff+200;
  sprintf(one, sbuff, destfib->fib_FileName, dsize, destdate, desttime);
  MakeBtnString(0,0,0); /* 2.5.28 rri */
  ch = DMReqTagList(one, 0, 0, warntags); /* 2.5.26 rri */
 }

return ch;
}


void CMD_Choose(void) /* 2.5b7 jjt (3.7.00) */
{
LONG   setconfirm, choice, bt, freq;
STRPTR btntxt, ret, retary[15], defstr, btnout; /* 2.5.23 jjt */
struct TagItem choosetags[]={{DMREQ_TITLE,     0}, /* 2.5.26 rri */
                             {DMREQ_BUTTONS,   0},
                             {DMREQ_ABORT,     0},
                             {DMREQ_MINW,      0},
                             {DMREQ_DEFBTN,    0},
                             {DMREQ_FILEREQ,   0},
                             {DMREQ_NOHELPBTN, TRUE}, /* 2.6 jjt */
                             {TAG_END,       0}};

setconfirm = GetActionArg("ASKONCE", AATYPE_BOOL, 0);
if (setconfirm && (FLAGS&DMFLAG_CONFIRM)) return; /* 2.5RC2 rri */

btntxt = (STRPTR) GetActionArg("BUTTONS", AATYPE_NEXTSTR, (LONG) msgGadOkay); /* 2.5b13 rri */

freq = GetActionArg("FILEREQ", AATYPE_BOOL, 0);  /* 2.5.26 jjt */

if (freq || (GetActionArg("STRING", AATYPE_BOOL, 0)))  /* 2.5.26 jjt */
 {
  strcpy(ReqStr, (STRPTR) GetActionArg("STRING", AATYPE_STR, (LONG) ""));
  defstr = ReqStr;
  btnout = sbuff;
 }
else
 {
  defstr=NULL;
  btnout=ReqStr;
 }

strcpy(dcPath, (STRPTR) GetActionArg("BUTTONVAR", AATYPE_NEXTSTR, (LONG) "BTNVAR"));  /* 2.5.23 jjt */

ret = (GetActionArg("RETBUTTONS", AATYPE_BOOL, 0) ? btntxt : (STRPTR) GetActionArg("RETURN", AATYPE_NEXTSTR, 0));

/* 2.5.26 rri */
choosetags[0].ti_Data = GetActionArg("TITLE", AATYPE_NEXTSTR, (LONG) Version);
choosetags[1].ti_Data = (ULONG) btntxt;
choosetags[2].ti_Data = GetActionArg("ABORT", AATYPE_NUM, -1);
choosetags[3].ti_Data = GetActionArg("MINW", AATYPE_NUM, 0);
choosetags[4].ti_Data = GetActionArg("DEFAULT", AATYPE_NUM, 1);
choosetags[5].ti_Data = freq;

choice = DMReqTagList((STRPTR) GetActionArg("TEXT", AATYPE_NEXTSTR, 0), defstr, 700, choosetags); /* 2.5.26 rri */

if (ret)
 {
  /* --- RETURN or RETBUTTONS was given --- */
  bt = strtoarray(StringPool, ret, retary, 15);
  if (choice == 0) choice = bt;  /* 2.5b11 jjt */
  strcpy(btnout, retary[choice - 1]);  /* 2.5.23 jjt */
  PoolFreeVec(*retary);
 }
else sprintf(btnout, "%ld", choice);  /* 2.5.23 */

outputRexxVar(btnout);  /* 2.5.23 jjt */
if (setconfirm) FLAGS|=DMFLAG_CONFIRM; /* 2.5RC2 rri */
rexxStr = ReqStr;
}


LONG DMReqTagList(CONST_STRPTR body, STRPTR dest, ULONG cmax, struct TagItem* tags)
{
  BOOL                 error=FALSE, showhelpbtn;
  UBYTE                *btnstrs[15], /* 2.7b9 rri ={0}, */
                       defgads[50], *titlestr,
                       *protlabels[8]={"_H", "_S", "_P", "_A", "_R", "_W", "_E", "_D"};
  WORD                 code, minw;
  UWORD                bgpat[2]={0x5555, 0xAAAA};
  LONG                 done=FALSE, choice=0, abortbtn, defbtn,
                       *protectptr, protectmask[8]={128,64,32,16,8,4,2,1}, n;
  ULONG                i, btotal, gid, signal, result, tidx, addFReq;
  STRPTR               bodynew, tmpstr, helpnode;
  struct Screen        *scrn;
  struct DrawInfo      *di;
// 2.7 rri  struct TextAttr      bdyta, btnta;
  struct Gadget        *strgad=NULL, *choosergad=NULL, *protectgads[8]; /* 2.7b9 rri ={0}; */
  struct StringInfo    *si=0;
  struct Window        *win;
  struct StringHistory *sh;
  struct TagItem       *btntags;
  struct List          histlist; /* 2.6 jjt */
  Object               *window=NULL, *strlayout=NULL, *protlayout=NULL, *button;

  memset(btnstrs,0,sizeof (btnstrs)); /* 2.7b9 rri */
  memset(protectgads,0,sizeof (protectgads)); /* 2.7b9 rri */

  /*
    body - "|" or \n = line break.
    dest - Buffer to copy string buffer to.  If NULL, then no string gadget appears.
    cmax - Maximum length of <dest>.
    tags - DMREQ_TITLE   - Defaults to Version.
           DMREQ_BUTTONS - Defaults to "Okay|Cancel".  Separate w/ a "|".
                           Ex:  "Yes|Maybe|No".
                           Maximum of 15 buttons.
           DMREQ_ABORT   - If the button pressed equals this number then Abort = 1 and
                           the req. returns 0.
                           Defaults to -1 (or 0xFFFFFFFF).
           DMREQ_SCREEN  - Screen pointer to open req. on.  Defaults to Screen.
           DMREQ_HISTORY - StringHistory struct to use.  Defaults to ReqHistory.
           DMREQ_MINW    - Minimum width of the req.  Defaults to (but will never be) 0.
           DMREQ_DEFBTN  - The button num. to return when <RETURN> is pressed.  Defaults to 1.
                           * Pressing <RETURN> in a string gadget will also return this
                             value.
                           * Button 0 cannot be the default.
                           * It's safe to use zero or numbers greater than the total number
                             of buttons.  In these cases "1" will be used.
           DMREQ_PROTREQ - Create a protection bits requester.  The value is the address of
                           a LONG which holds the protection bits.  The protection buttons
                           will be initialized according to this var, & the req. will also
                           copy the new values into this var.
                           Automatically sets DMREQ_HELPNODE to "Protect".
           DMREQ_FILEREQ - Adds a button beside the string gadget that can open a file req.
                               * Ignored if <dest> is NULL.
           DMREQ_HELPNODE  - Pressing the <HELP> key or "?" button will open DiskMaster2Guide
                             to this node.
                             Defaults to "Main".
           DMREQ_NOHELPBTN - If not NULL, the Help ("?") button will not be displayed.
                             Does not affect the <HELP> key, which is always available.

    DMReq() returns the number (LONG) of the button pressed.  Buttons are numbered
    1, 2, 3, ..., 0.
    Pressing <Return> returns 1, Esc = 0.
    If DMREQ_ABORT <> -1 then Esc will also set the Abort flag.
  */

  Busy(1);

  scrn = (struct Screen *) GetTagData(DMREQ_SCREEN, (ULONG) Screen, tags);
  di = GetScreenDrawInfo(scrn);

  sh = (struct StringHistory *) GetTagData(DMREQ_HISTORY, (ULONG) &ReqHistory, tags);
  makeCALabels(&histlist, (STRPTR *) sh->strcache, FALSE); /* ClassAct */ /* 2.6 jjt */
  helpnode = (STRPTR) GetTagData(DMREQ_HELPNODE, (ULONG) "Main", tags);  /* 2.6 jjt */

  showhelpbtn = GetTagData(DMREQ_NOHELPBTN, 0, tags) ? FALSE : Req_ShowHelpBtn;  /* 2.6 jjt */

  /* Set up TextAttrs for body & button fonts... */
/* 2.7 rri - obsolete, already part of DMTextAttrs[] */
//  FontToAttr(DMFonts[DMFONTS_REQTXT], &bdyta);
//  FontToAttr(DMFonts[DMFONTS_REQBTN], &btnta);

  titlestr = (UBYTE *) GetTagData(DMREQ_TITLE, (ULONG) Version, tags);

  /* Copy <body> to <bodynew>, and convert '|'s to LFs... */  /* 2.6 jjt  */
  bodynew = CloneStr(body, StringPool);
  tmpstr = bodynew;
  while (*tmpstr)
  {
    if (*tmpstr == '|')
    {
      *tmpstr = '\n';
    }
    tmpstr++;
  }

  sprintf(defgads,"%s|%s",msgGadOkay,msgGadCancel);
  tmpstr = (STRPTR) GetTagData(DMREQ_BUTTONS, (ULONG) defgads, tags);
  btotal = strtoarray(sh->mempool, tmpstr, (STRPTR *) btnstrs, 15); /* 2.6 rri */
  defbtn = GetTagData(DMREQ_DEFBTN, 1, tags);
  if ((defbtn == (LONG) 0) || (defbtn > (LONG) btotal)) defbtn = 1;
  abortbtn = GetTagData(DMREQ_ABORT, 0xFFFFFFFF, tags);

  /* Build string gad (maybe)... */
  if (dest)
  {
    addFReq = GetTagData(DMREQ_FILEREQ, 0, tags);

    strlayout = HLayoutObject,
      LAYOUT_SpaceInner, FALSE,
/*      GA_TextAttr, &bdyta, // Test - works */
      LAYOUT_AddChild, strgad = StringObject,
        GA_ID, defbtn,
/*         GA_TextAttr, &bdyta, */
        GA_UserData, sh,
        STRINGA_TextVal, dest,
        STRINGA_MaxChars, cmax,
        STRINGA_EditHook, &EditHook,
        STRINGA_ExitHelp, TRUE,
      StringEnd,
      CHILD_NominalSize, TRUE,

      sh->total ? TAG_IGNORE : TAG_SKIP, 2,  /* No chooser if string history is empty */
      LAYOUT_AddChild, choosergad = ChooserObject,
        GA_ID, GID_CHOOSER,
        GA_RelVerify, TRUE,
        CHOOSER_DropDown, TRUE,
        /* CHOOSER_LabelArray, sh->strcache, */
        CHOOSER_Labels, &histlist, /* ClassAct */ /* 2.6 jjt */
        CHOOSER_MaxLabels, STRHIST_MAX,  /* 2.6 jjt */
        CHOOSER_AutoFit, TRUE,
      ChooserEnd,
      CHILD_WeightedWidth, 0,

      addFReq ? TAG_IGNORE : TAG_SKIP, 2,  /* Request file button? */
      LAYOUT_AddChild, ButtonObject,
        GA_ID, GID_FILEREQ,
        GA_RelVerify, TRUE,
        BUTTON_AutoButton, BAG_POPFILE,
      ButtonEnd,
      CHILD_WeightedWidth, 0,

    LayoutEnd;

    if (!strlayout) error = TRUE;

    si = (struct StringInfo *) strgad->SpecialInfo;
  }

  /* Build protection bit buttons (possibly)... */
  if ( (protectptr = (LONG *) GetTagData(DMREQ_PROTREQ, 0, tags)) ) /* 2.6 rri */
  {
    helpnode = "Protect";  /* 2.6 jjt */

    n = *protectptr ^ 15;  /* Protection bits w/ REWD reversed. */

    for (i=0; i < 8; i++)
    {
      protectgads[i] = NewObject(NULL, "button.gadget",
        GA_ID, GID_PROTECT,
        GA_Text, protlabels[i],
        GA_Selected, n & protectmask[i],
        BUTTON_PushButton, TRUE,
        TAG_END);
    }

    protlayout = HLayoutObject,
      LAYOUT_SpaceOuter, TRUE,
      LAYOUT_FillPen, di->dri_Pens[SHINEPEN],
      LAYOUT_FillPattern, bgpat,
      LAYOUT_AddChild, protectgads[4],  /* R */
      CHILD_WeightedWidth, 0,
      LAYOUT_AddChild, protectgads[5],  /* W */
      CHILD_WeightedWidth, 0,
      LAYOUT_AddChild, protectgads[6],  /* E */
      CHILD_WeightedWidth, 0,
      LAYOUT_AddChild, protectgads[7],  /* D */
      CHILD_WeightedWidth, 0,
      LAYOUT_AddChild, protectgads[1],  /* S */
      CHILD_WeightedWidth, 0,
      LAYOUT_AddChild, protectgads[2],  /* P */
      CHILD_WeightedWidth, 0,
      LAYOUT_AddChild, protectgads[3],  /* A */
      CHILD_WeightedWidth, 0,
      LAYOUT_AddChild, protectgads[0],  /* H */
      CHILD_WeightedWidth, 0,
    LayoutEnd;

    if (!protlayout) error = TRUE;
  }

  /* Build button(s)... */
  if ( (btntags = AllocateTagItems(btotal * 2)) ) /* 2.6 rri */
  {
    tidx = 0;
    gid = 1;
    for (i = 0; i < btotal; i++)
    {
      button = NewObject(NULL, "button.gadget",
                         GA_TextAttr, &DMTextAttrs[DMFONTS_REQBTN], /* 2.7 rri */
                         BUTTON_SoftStyle, (LONG) (i + 1) == defbtn ? FSF_BOLD: FS_NORMAL, /* 2.6 rri */
                         GA_Text, btnstrs[i],
                         GA_ID, gid == btotal ? 0 : gid++,
                         GA_RelVerify, TRUE,
                         TAG_END);

      btntags[tidx].ti_Tag = LAYOUT_AddChild;
      btntags[tidx++].ti_Data = (ULONG) button;
      btntags[tidx].ti_Tag = CHILD_WeightedWidth;
      btntags[tidx++].ti_Data = 0;
    }
  }
  else error = TRUE;

  if (!error)
  {
    window = WindowObject,
      WINDOW_Position, WPOS_CENTERSCREEN,
      WINDOW_LockHeight, TRUE,
      WINDOW_GadgetUserData, WGUD_IGNORE,
      WINDOW_TextAttr, &DMTextAttrs[DMFONTS_REQTXT], /* 2.7 rri */
      WA_Activate, TRUE,
      WA_Title, titlestr,
      WA_DragBar, TRUE,
      WA_DepthGadget, TRUE,
      dest ? WA_SizeGadget : TAG_IGNORE, TRUE,
      WA_SizeBBottom, TRUE,
      WA_PubScreen,  scrn,
      WA_IDCMP, IDCMP_ACTIVEWINDOW|IDCMP_GADGETUP|IDCMP_RAWKEY|IDCMP_VANILLAKEY,
      WINDOW_ParentGroup, VLayoutObject,
        LAYOUT_DeferLayout, TRUE,
        LAYOUT_SpaceInner, TRUE,
        LAYOUT_SpaceOuter, TRUE,
        LAYOUT_FillPen, di->dri_Pens[SHINEPEN],
        LAYOUT_FillPattern, bgpat,

        LAYOUT_AddChild, HGroupObject,  /* 2.6 jjt */
          LAYOUT_SpaceInner, FALSE,

          /* Body text */
          LAYOUT_AddChild, VGroupObject,
            GA_BackFill, NULL,
            LAYOUT_SpaceOuter, TRUE,
            LAYOUT_VertAlignment, LALIGN_CENTER,
            LAYOUT_HorizAlignment, LALIGN_CENTER,
            LAYOUT_BevelStyle, BVS_THIN,
            LAYOUT_BevelState, IDS_SELECTED,
            LAYOUT_FillPattern, NULL,
            LAYOUT_AddImage, LabelObject,
              IA_Font, &DMTextAttrs[DMFONTS_REQTXT], /* 2.7 rri */
              IA_Underscore, 8,  /* 2.6 jjt */
              LABEL_Text, bodynew,
            LabelEnd,
          LayoutEnd,

          /* Help button */ /* 2.6 jjt */
          showhelpbtn ? TAG_IGNORE : TAG_SKIP, 2,  /* 2.6 jjt */
          LAYOUT_AddChild, ButtonObject,
            GA_ID, GID_HELP,
            GA_RelVerify, TRUE,
/*             GA_TextAttr, &btnta, */
            GA_Text, "_?",
          ButtonEnd,
          CHILD_WeightedWidth, 0,

        LayoutEnd,

        /* String gad (maybe) */
        !strlayout ? TAG_IGNORE : LAYOUT_AddChild, strlayout,

        /* Protection buttons (at times) */
        !protlayout ? TAG_IGNORE : LAYOUT_AddChild, protlayout,

        /* Buttons */
        LAYOUT_AddChild, HLayoutObject,
          LAYOUT_EvenSize, TRUE,
          LAYOUT_HorizAlignment, btotal == 1 ? LALIGN_CENTER : LALIGN_LEFT,
          LAYOUT_FillPen, di->dri_Pens[SHINEPEN],
          LAYOUT_FillPattern, bgpat,
/*           LAYOUT_TopSpacing, 2, */
          TAG_MORE, btntags,
        LayoutEnd,

      LayoutEnd,
    WindowEnd;

    if (window) /* 2.6 jjt */
    {
      /* Set width to minimum, if necessary... (Reaction doesn't offer WA_MinWidth) */
      minw = GetTagData(DMREQ_MINW, 0, tags);  /* User-specified minw*/
      i = TextLength(&scrn->RastPort, titlestr, (ULONG) strlen(titlestr));  /* Window title width */
      minw = max (minw, (WORD) i); /* 2.6 rri */
      GetAttr(WA_Width, window, &i);
      if (minw > (WORD) i) /* 2.6 rri */
      {
        SetAttrs(window, WA_Width, minw, TAG_END);
      }
    }
  }

  if (window && (win = (struct Window *) RA_OpenWindow(window)))
  {
    /* Obtain the window wait signal mask */
    GetAttr(WINDOW_SigMask, window, &signal);

    if (dest) ActivateGadget(strgad, win, NULL); /* CLassAct*/ /* 2.6 jjt */

    /* Input Event loop... */
    while (!done)
    {
      Wait(signal);
      while ((result = RA_HandleInput(window, &code)) != WMHI_LASTMSG)
      {
        switch (result & WMHI_CLASSMASK)
        {
          case WMHI_ACTIVE:
            if (dest)
            {
              ActivateGadget(strgad, win, NULL);
            }
            break;

          case WMHI_RAWKEY:
            if ((result & WMHI_KEYMASK) == 0x5F) /* Help pressed */
            {
              ViewAsync(DiskMaster2Guide, helpnode); /* 2.6 jjt */
            }
            break;

          case WMHI_VANILLAKEY:
            gid = result & WMHI_KEYMASK;
            if (gid == 27)  /* Esc pressed */
            {
              done = TRUE;
              choice = abortbtn == -1 ? 0 : abortbtn;
            }
            else if (gid == 13)  /* Return pressed */
            {
              done = TRUE;
              choice = defbtn;
            }
            break;

          case WMHI_GADGETUP:
            gid = result & WMHI_GADGETMASK;
            if (gid == GID_CHOOSER)
            {
              GetAttr(CHOOSER_Selected, choosergad, &i);
              SetGadgetAttrs(strgad, win, NULL, STRINGA_TextVal, sh->strcache[i], TAG_END);
              ActivateGadget(strgad, win, NULL);
            }
            else if (gid == GID_FILEREQ)
            {
              tmpstr = DMFileReq(si->Buffer, 0, FALSE);
              if (*tmpstr) SetGadgetAttrs(strgad, win, NULL, STRINGA_TextVal, tmpstr, TAG_END);
            }
            else if (gid == GID_HELP) /* 2.6 jjt */
            {
              ViewAsync(DiskMaster2Guide, helpnode);
            }
            else if (code == 27)  /* 2.6 jjt */
            {
              /* User Escaped string gad */
              done = TRUE;
              choice = abortbtn == -1 ? 0 : abortbtn;
            }
            else if (code != 0x5F)
            {
              done = TRUE;
              choice = gid;
            }
/*
// The following would launch the context help when the user presses Help inside a string
// gadget, but to make it work GA_RelVerify needs to be set.  ...And that brings back the
// repeating Returns nightmare.
            else
            {
              ViewAsync(DiskMaster2Guide, helpnode);
            }
*/
            break;

        } /* end switch WMHI_CLASSMASK*/
      } /* end while window msg */
    } /* end while !done */

    if (choice == abortbtn)
    {
      choice = 0;
      FLAGS|=DMFLAG_ABORT;
    }

    if (choice)  /* 2.6 jjt */
    {
      if (dest)
      {
        strcpy(dest, si->Buffer);
        StrHist_Add(sh, dest);
      }
      if (protectptr)
      {
        n = 0;
        for (i=0; i < 8; i++)
        {
          if (protectgads[i]->Flags & GFLG_SELECTED) n |= protectmask[i];
        }
        *protectptr = n ^ 15;
      }
    }

    DisposeObject(window);
  }

  if (btntags) FreeTagItems(btntags);
  PoolFreeVec(bodynew); /* 2.6 jjt */
  PoolFreeVec(*btnstrs);
  freeCALabels(&histlist, FALSE); /* ClassAct */ /* 2.6 jjt */

  Busy(0);
  return choice;
}


ULONG strtoarray(APTR mempool, CONST_STRPTR str, STRPTR strary[], ULONG arymax) /* 2.5b10 jjt */
{
UBYTE *sptr;
ULONG c, stotal=0;

if (str && (sptr = CloneStr(str, mempool)))
 {
  for(c = 1;(stotal < arymax && c != 0); stotal++) /* 2.5.26 rri */
   {
    strary[stotal] = sptr;
    for (;;)
     {
      c = *sptr++;
      if ((c == '\n') || (c == '|') || (c == 0))
       {
        *(sptr - 1) = 0;
        break;
       }
     }
   }
 }
for (c = stotal; c < arymax; c++) strary[c] = 0; /* Zero-out remaining elements. */

return stotal;
}


void MakeBtnString(const UBYTE yes[], const UBYTE middle[], const UBYTE no[]) /* 2.5b13 rri */
{
strcpy(g_buttons, yes ? yes : msgGadOkay); /* 2.5b13 rri */
DMstrcat(g_buttons, "|"); /* 2.5RC9 rri */

if (middle)
 {
  DMstrcat(g_buttons, middle); /* 2.5RC9 rri */
  DMstrcat(g_buttons, "|"); /* 2.5RC9 rri */
 }
DMstrcat(g_buttons, no ? no : msgGadCancel); /* 2.5RC9 rri */
}


void StrHist_Init(struct StringHistory *sh) {  /* 2.5b10 jjt */
   ULONG i;

/*  InitSemaphore(&(sh->sema4)); */

  for (i=0; i <= STRHIST_MAX; i++) /* 2.6 jjt */
  {
    /* Chooser gadgets need null-terminated arrays. */
    sh->strcache[i] = NULL;
  }
  sh->mempool = StringPool;
  sh->cachepos = sh->total = 0;
}


/*
void StrHist_Clear(struct StringHistory *sh) {
  ULONG                  i;
  struct SignalSemaphore *sammy;

  sammy = &sh->sema4;
  ObtainSemaphore(sammy);
  for(i=0; i < sh->total; i++) {
    PoolFreeVec(sh->strcache[i]);

    sh->strcache[i] = NULL;

  }
  sh->cachepos = sh->total = 0;
  ReleaseSemaphore(sammy);
}
*/


void StrHist_Add(struct StringHistory *sh, STRPTR str) {  /* 2.5b10 jjt */
  UBYTE                  *sptr;
  LONG                   l;
  ULONG                  i; /* 2.5.23 gcc rri */
/*
  struct SignalSemaphore *sammy;

  sammy = &sh->sema4;
  ObtainSemaphore(sammy);
*/

  if (str && (l = strlen(str))) {
    /* --- Check if string already exists --- */
    for(i=0; i < sh->total; i++) {
      if (Stricmp(sh->strcache[i], str) == 0) {  /* 2.5b12 jjt */
        /* --- Already cached; move it to end of cache. --- */
        sptr = sh->strcache[i];
        i += 1;
        goto ashift;
      }
    }

    /* --- Clone string & add it to the cache --- */
    if ((sptr = CloneStr(str, sh->mempool))) {
      if (sh->total == STRHIST_MAX) {
        /* --- Cache full; dump first item & shift the array --- */
        PoolFreeVec(sh->strcache[0]);
        i = 1;
ashift: for(; i < STRHIST_MAX; i++) {
          sh->strcache[i - 1] = sh->strcache[i];
        }
        sh->total -= 1;
      }
      sh->strcache[sh->total] = sptr;
      sh->total += 1;
    }
  }

  sh->cachepos = sh->total;
/*   ReleaseSemaphore(sammy); */
}


/* 2.5b10 jjt */
ULONG SAVEDS ASM StringHook(REG(a0,struct Hook *hk),      /* 2.5.26 rri */
                            REG(a2,struct SGWork *swork),
                            REG(a1, ULONG *msg))
{
LONG   dir = 0;
ULONG  cp, /* 2.5.23 gcc rri */
       rc = 0xFFFFFFFF, jump = 0;
struct StringHistory *sh;
/*  UBYTE *bla[20]; // Debug */

if(hk) {} /* 2.5.23 gcc rri - just some dummy code to make it look like hk is used...*/

if (*msg == SGH_KEY)
 {
  if (swork->Code == 27)  /* Catch Esc (non-Reaction string gads) */
   {
    restorestrcontents(swork);
    swork->Actions |= SGA_USE | SGA_END;
   }
  else if (swork->IEvent->ie_Class == IECLASS_RAWKEY)
   {
    if (swork->IEvent->ie_Code == 0x45)  /* Catch Esc (Reaction string gads) */ /* 2.6 jjt */
    {
      restorestrcontents(swork);
      swork->Code = 27;
      swork->Actions |= SGA_USE | SGA_END;
    }
    else if (swork->IEvent->ie_Code == CURSORUP) dir = -1;
    else if (swork->IEvent->ie_Code == CURSORDOWN) dir = 1;
/*
    // Debug - Return raw key code in the str gad.
    else
    {
      sprintf(bla, "%lx", swork->IEvent->ie_Code);
      strcpy(swork->WorkBuffer, bla);
      swork->NumChars = swork->BufferPos = strlen(bla);
      swork->Actions |= SGA_USE | SGA_END | SGA_BEEP;
    }
*/
    jump = swork->IEvent->ie_Qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT);
   }
 }
else if (*msg != SGH_CLICK) rc = 0;

if (dir)
 {
  sh = (struct StringHistory *) swork->Gadget->UserData;
  if (sh->total)
   {
    if (jump) cp = (dir == 1) ? sh->total : 0;
    else
     {
      cp = sh->cachepos + dir;
      if (cp > sh->total) cp = (dir == 1) ? sh->total : 0; /* 2.5.29 jjt */
     }
    if (cp == sh->total) restorestrcontents(swork);
    else
     {
/*    ObtainSemaphore(&sh->sema4); */
      CopyMem(sh->strcache[cp],swork->WorkBuffer,(ULONG) ((struct StringInfo *) swork->Gadget->SpecialInfo)->MaxChars - 1); /* 2.5RC9 rri */
      swork->NumChars = swork->BufferPos = strlen(sh->strcache[cp]); /* 2.6 jjt */
/*    ReleaseSemaphore(&sh->sema4); */
     }
    sh->cachepos = cp;
    swork->Actions |= SGA_USE;
   }
 }
return (ULONG) rc;
}


void restorestrcontents(struct SGWork * swork) {  /* 2.5b10 jjt */
  strcpy(swork->WorkBuffer, ((struct StringInfo *) swork->Gadget->SpecialInfo)->UndoBuffer);
  swork->NumChars = swork->BufferPos = strlen(((struct StringInfo *) swork->Gadget->SpecialInfo)->UndoBuffer);
}


STRPTR DMFileReq(STRPTR file, STRPTR path, BOOL save) /* 2.5.27 rri */
{
struct FileRequester *dm2_filereq;

*sbuff=0;

if(AslBase)
 {
  dm2_filereq = AllocAslRequestTags(ASL_FileRequest,
                                    ASLFR_TitleText, Version,
                                    ASLFR_Screen, Screen,
                                    ASLFR_DoSaveMode, save,
                                    ASLFR_DoMultiSelect, FALSE,
                                    TAG_DONE);
  if (dm2_filereq != NULL)
   {
    if(file&&!path) /* 2.5.27 rri */
     {

      strcpy(sbuff,file);
      *PathPart(sbuff)=0;
     }
    else
     {
      if(path) /* 2.5.27 rri */
       {
        strcpy(sbuff,path);
       }
      file=sbuff;
     }
    Busy(1);
    if (AslRequestTags(dm2_filereq,
                       ASLFR_InitialFile, FilePart(file),
                       ASLFR_InitialDrawer, sbuff,
                       TAG_DONE))
     {
      if(*dm2_filereq->fr_File)
       {
        strcpy(sbuff,dm2_filereq->fr_Drawer);
        AddPart(sbuff,dm2_filereq->fr_File,500);
       }
      else
       {
        *sbuff=0;
       }
     }
    else
     {
      *sbuff=0;
     }
    Busy(0);
    FreeAslRequest(dm2_filereq);
   }
 }
return(sbuff);
}

